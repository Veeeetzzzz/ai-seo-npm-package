# v1.11.0 Lite - Implementation Plan

**Release:** v1.11.0 - Complete AI Search Optimizers  
**Timeline:** 2 weeks  
**Type:** Feature Release (Minor)  
**Breaking Changes:** None  
**Bundle Target:** <9 kB gzipped

---

## ðŸŽ¯ Core Objectives

1. âœ… Complete all 4 placeholder AI search optimizers (rule-based)
2. âœ… Add 10+ new schema templates for common use cases
3. âœ… Improve keyword & entity extraction algorithms
4. âœ… Basic schema relationship detection
5. âœ… Comprehensive testing & documentation

---

## ðŸ“‹ Detailed Feature Breakdown

### Feature 1: Bard/Gemini Optimizer (Rule-Based)

**File:** `index.js` (Update BardOptimizer class)

**Implementation:**

```javascript
class BardOptimizer {
  constructor() {
    this.config = {
      multiModalOptimization: true,
      knowledgeGraphAlignment: true,
      conversationalEnhancement: true
    };
  }

  async optimize(schema, options = {}) {
    let optimized = JSON.parse(JSON.stringify(schema));

    // 1. Multi-modal metadata hints
    optimized = this.addVisualMetadata(optimized);
    
    // 2. Knowledge Graph property mapping
    optimized = this.alignWithKnowledgeGraph(optimized);
    
    // 3. Conversational + factual hybrid structure
    optimized = this.buildHybridStructure(optimized);
    
    // 4. Rich media references
    optimized = this.enrichWithMediaHints(optimized);
    
    // 5. Add Gemini-specific optimization markers
    optimized._aiOptimization = {
      target: 'bard-gemini',
      optimizations: [
        'multi-modal-hints',
        'knowledge-graph-aligned',
        'conversational-hybrid',
        'media-enriched'
      ],
      timestamp: new Date().toISOString()
    };

    return optimized;
  }

  addVisualMetadata(schema) {
    // Add image-related hints for multi-modal understanding
    if (schema.image) {
      const images = Array.isArray(schema.image) ? schema.image : [schema.image];
      schema.associatedMedia = images.map(img => ({
        '@type': 'ImageObject',
        contentUrl: img,
        description: schema.name || 'Image',
        encodingFormat: 'image/jpeg',
        // Hint for visual search
        representativeOfPage: true
      }));
    }
    
    // Suggest alt-text structure
    if (schema['@type'] === 'Product' || schema['@type'] === 'Article') {
      schema.about = schema.about || {
        '@type': 'Thing',
        name: schema.name,
        description: schema.description
      };
    }
    
    return schema;
  }

  alignWithKnowledgeGraph(schema) {
    // Add properties that align with Google Knowledge Graph
    const kgProperties = {
      sameAs: [], // Links to authoritative sources
      additionalType: [], // More specific types
      subjectOf: [] // Related content
    };
    
    // For organizations, add knowledge graph hints
    if (schema['@type'] === 'Organization' || schema['@type'] === 'LocalBusiness') {
      if (schema.url && !schema.sameAs) {
        schema.sameAs = schema.sameAs || [];
        // Suggest adding social profiles for KG
      }
      
      if (!schema.logo && schema.image) {
        schema.logo = Array.isArray(schema.image) ? schema.image[0] : schema.image;
      }
    }
    
    // Add disambiguating description
    if (schema.description && !schema.disambiguatingDescription) {
      const brief = schema.description.split('.')[0];
      if (brief.length < 100) {
        schema.disambiguatingDescription = brief;
      }
    }
    
    return schema;
  }

  buildHybridStructure(schema) {
    // Combine conversational and factual elements
    
    // Add FAQ structure if product/service
    if (['Product', 'Service', 'LocalBusiness'].includes(schema['@type'])) {
      const faqs = this.generateCommonFAQs(schema);
      if (faqs.length > 0) {
        schema.mainEntity = schema.mainEntity || faqs;
      }
    }
    
    // Add "how to" actions if applicable
    if (schema['@type'] === 'HowTo' || schema.name?.toLowerCase().includes('how to')) {
      schema.step = schema.step || [];
    }
    
    return schema;
  }

  enrichWithMediaHints(schema) {
    // Add video hints if relevant
    if (schema['@type'] === 'Product' || schema['@type'] === 'HowTo') {
      schema.video = schema.video || {
        '@type': 'VideoObject',
        name: `${schema.name} - Overview`,
        description: schema.description,
        // Placeholder - encourages adding video
        thumbnailUrl: schema.image || ''
      };
    }
    
    return schema;
  }

  generateCommonFAQs(schema) {
    const faqs = [];
    const type = schema['@type'];
    const name = schema.name || 'item';
    
    if (type === 'Product') {
      faqs.push({
        '@type': 'Question',
        name: `What is ${name}?`,
        acceptedAnswer: {
          '@type': 'Answer',
          text: schema.description || `${name} is a product.`
        }
      });
      
      if (schema.brand) {
        faqs.push({
          '@type': 'Question',
          name: `Who makes ${name}?`,
          acceptedAnswer: {
            '@type': 'Answer',
            text: `${name} is made by ${schema.brand.name || schema.brand}.`
          }
        });
      }
    }
    
    return faqs.slice(0, 3); // Top 3 FAQs
  }
}
```

**Estimated:** 1.5 days

---

### Feature 2: Perplexity Optimizer (Rule-Based)

**File:** `index.js` (Update PerplexityOptimizer class)

**Implementation:**

```javascript
class PerplexityOptimizer {
  constructor() {
    this.config = {
      researchFocused: true,
      citationFormat: true,
      factDensity: 'high'
    };
  }

  async optimize(schema, options = {}) {
    let optimized = JSON.parse(JSON.stringify(schema));

    // 1. Research-friendly structure
    optimized = this.buildResearchFormat(optimized);
    
    // 2. Citation structure
    optimized = this.addCitationStructure(optimized);
    
    // 3. Source attribution
    optimized = this.enhanceSourceAttribution(optimized);
    
    // 4. Fact density optimization
    optimized = this.optimizeFactDensity(optimized);
    
    // 5. Academic markers
    optimized = this.addAcademicMarkers(optimized);
    
    optimized._aiOptimization = {
      target: 'perplexity',
      optimizations: [
        'research-structured',
        'citation-ready',
        'source-attributed',
        'fact-dense',
        'academic-markers'
      ],
      timestamp: new Date().toISOString()
    };

    return optimized;
  }

  buildResearchFormat(schema) {
    // Add research paper-style structure
    
    // Add abstract/summary
    if (schema.description && !schema.abstract) {
      schema.abstract = schema.description;
    }
    
    // Add keywords for research indexing
    if (schema.name && !schema.keywords) {
      schema.keywords = this.extractResearchKeywords(schema.name + ' ' + (schema.description || ''));
    }
    
    // Add subject matter classification
    if (!schema.about) {
      schema.about = {
        '@type': 'Thing',
        name: schema.name
      };
    }
    
    return schema;
  }

  addCitationStructure(schema) {
    // Add citation metadata
    
    // For articles, add citation object
    if (schema['@type'] === 'Article' || schema['@type'] === 'ScholarlyArticle') {
      schema.citation = schema.citation || [];
      
      // Add publication info
      if (schema.datePublished && !schema.datePublished.includes('citation')) {
        // Structured citation data
      }
    }
    
    // Add publisher info if missing
    if (schema.author && !schema.publisher) {
      schema.publisher = {
        '@type': 'Organization',
        name: 'Published by ' + (schema.author.name || schema.author)
      };
    }
    
    // Add ISSN/ISBN placeholders for academic content
    if (schema['@type'] === 'Article') {
      schema.issn = schema.issn || 'ISSN placeholder';
    }
    
    return schema;
  }

  enhanceSourceAttribution(schema) {
    // Add comprehensive source information
    
    // Add provenance
    if (!schema.provider) {
      schema.provider = {
        '@type': 'Organization',
        name: 'Source provider'
      };
    }
    
    // Add fact-checking claims structure
    if (schema['@type'] === 'Article' || schema['@type'] === 'ClaimReview') {
      schema.claimReviewed = schema.claimReviewed || schema.headline;
    }
    
    // Add author credentials
    if (schema.author && typeof schema.author === 'object') {
      schema.author.jobTitle = schema.author.jobTitle || 'Subject matter expert';
    }
    
    return schema;
  }

  optimizeFactDensity(schema) {
    // Ensure high information density
    
    // Break down complex descriptions
    if (schema.description && schema.description.length > 200) {
      const sentences = schema.description.match(/[^.!?]+[.!?]+/g) || [];
      
      // Add key points
      if (sentences.length > 2) {
        schema.mainEntity = schema.mainEntity || sentences.slice(0, 3).map(s => ({
          '@type': 'Thing',
          name: s.trim()
        }));
      }
    }
    
    // Add data points as properties
    if (schema['@type'] === 'Product') {
      schema.additionalProperty = schema.additionalProperty || [];
    }
    
    return schema;
  }

  addAcademicMarkers(schema) {
    // Add academic/research indicators
    
    // Add educational alignment if applicable
    if (schema['@type'] === 'Article' || schema['@type'] === 'Course') {
      schema.educationalLevel = schema.educationalLevel || 'Advanced';
      schema.educationalUse = schema.educationalUse || 'Research';
    }
    
    // Add expertise markers
    if (schema.author) {
      schema.author.knowsAbout = schema.about?.name || schema.keywords;
    }
    
    return schema;
  }

  extractResearchKeywords(text) {
    // Extract academic-style keywords
    const words = text.toLowerCase().split(/\s+/);
    const significantWords = words.filter(w => w.length > 5);
    return significantWords.slice(0, 5).join(', ');
  }
}
```

**Estimated:** 1.5 days

---

### Feature 3: Voice Search Optimizer (Rule-Based)

**File:** `index.js` (Update VoiceSearchOptimizer class)

**Implementation:**

```javascript
class VoiceSearchOptimizer {
  constructor() {
    this.config = {
      questionAnswerFormat: true,
      naturalLanguage: true,
      conversationalMarkers: true,
      localContext: true
    };
  }

  async optimize(schema, options = {}) {
    let optimized = JSON.parse(JSON.stringify(schema));

    // 1. Question-answer structure
    optimized = this.buildQAStructure(optimized);
    
    // 2. Natural language variations
    optimized = this.generateNLVariations(optimized);
    
    // 3. Voice query patterns
    optimized = this.addVoicePatterns(optimized);
    
    // 4. Conversational context
    optimized = this.addConversationalContext(optimized);
    
    // 5. Featured snippet optimization
    optimized = this.optimizeForSnippets(optimized);
    
    optimized._aiOptimization = {
      target: 'voice-search',
      optimizations: [
        'qa-structured',
        'natural-language',
        'voice-patterns',
        'conversational-context',
        'snippet-optimized'
      ],
      timestamp: new Date().toISOString()
    };

    return optimized;
  }

  buildQAStructure(schema) {
    // Generate voice-friendly Q&A
    const questions = this.generateVoiceQuestions(schema);
    
    if (questions.length > 0) {
      schema.mainEntity = schema.mainEntity || questions;
    }
    
    // Add speakable content markers
    schema.speakable = {
      '@type': 'SpeakableSpecification',
      cssSelector: ['.title', '.summary', '.description']
    };
    
    return schema;
  }

  generateVoiceQuestions(schema) {
    const questions = [];
    const type = schema['@type'];
    const name = schema.name || 'item';
    
    // Who questions
    if (schema.author || schema.brand || schema.manufacturer) {
      const who = schema.author?.name || schema.brand?.name || schema.brand || schema.manufacturer;
      questions.push({
        '@type': 'Question',
        name: `Who created ${name}?`,
        acceptedAnswer: {
          '@type': 'Answer',
          text: `${name} was created by ${who}.`
        }
      });
    }
    
    // What questions
    questions.push({
      '@type': 'Question',
      name: `What is ${name}?`,
      acceptedAnswer: {
        '@type': 'Answer',
        text: schema.description || `${name} is a ${type.toLowerCase()}.`
      }
    });
    
    // Where questions (for local businesses)
    if (schema.address || schema.location) {
      const where = schema.address?.addressLocality || schema.location?.name || 'various locations';
      questions.push({
        '@type': 'Question',
        name: `Where is ${name} located?`,
        acceptedAnswer: {
          '@type': 'Answer',
          text: `${name} is located in ${where}.`
        }
      });
    }
    
    // When questions (for events)
    if (schema.startDate) {
      questions.push({
        '@type': 'Question',
        name: `When is ${name}?`,
        acceptedAnswer: {
          '@type': 'Answer',
          text: `${name} starts on ${new Date(schema.startDate).toLocaleDateString()}.`
        }
      });
    }
    
    // Why questions (value proposition)
    if (schema.description) {
      questions.push({
        '@type': 'Question',
        name: `Why choose ${name}?`,
        acceptedAnswer: {
          '@type': 'Answer',
          text: schema.description
        }
      });
    }
    
    // How questions (usage/process)
    if (type === 'HowTo' || type === 'Recipe') {
      questions.push({
        '@type': 'Question',
        name: `How do I use ${name}?`,
        acceptedAnswer: {
          '@type': 'Answer',
          text: schema.description || 'Follow the instructions provided.'
        }
      });
    }
    
    return questions.slice(0, 5); // Top 5 Q&As
  }

  generateNLVariations(schema) {
    // Add natural language alternatives
    const name = schema.name;
    
    if (name) {
      const variations = [
        name,
        `Tell me about ${name}`,
        `Information about ${name}`,
        `What can you tell me about ${name}`,
        `${name} details`
      ];
      
      schema.alternateName = schema.alternateName || variations.slice(1, 3);
    }
    
    return schema;
  }

  addVoicePatterns(schema) {
    // Add common voice search patterns as keywords
    const type = schema['@type'];
    const name = schema.name || '';
    
    const patterns = [];
    
    // Near me patterns (for local)
    if (type === 'LocalBusiness' || type === 'Restaurant') {
      patterns.push(`${name} near me`, `${name} nearby`, `closest ${name}`);
    }
    
    // Best/top patterns
    if (type === 'Product' || type === 'Service') {
      patterns.push(`best ${name}`, `top ${name}`, `${name} reviews`);
    }
    
    // How to patterns
    if (type === 'HowTo' || type === 'Recipe') {
      patterns.push(`how to use ${name}`, `${name} tutorial`, `${name} guide`);
    }
    
    // Add as keywords
    if (patterns.length > 0) {
      const existing = schema.keywords || '';
      const keywordArray = existing.split(',').map(k => k.trim()).filter(Boolean);
      schema.keywords = [...new Set([...keywordArray, ...patterns])].join(', ');
    }
    
    return schema;
  }

  addConversationalContext(schema) {
    // Add conversational markers
    
    // Add potential action for voice commands
    if (!schema.potentialAction) {
      schema.potentialAction = {
        '@type': 'SearchAction',
        target: {
          '@type': 'EntryPoint',
          urlTemplate: 'search?q={search_term_string}',
          actionPlatform: ['voice', 'mobile']
        },
        'query-input': 'required name=search_term_string'
      };
    }
    
    // Add interaction statistic hints
    if (schema['@type'] === 'Product' && schema.aggregateRating) {
      // Voice assistants like review counts
      schema.review = schema.review || {
        '@type': 'Review',
        reviewRating: {
          '@type': 'Rating',
          ratingValue: schema.aggregateRating.ratingValue || 4
        }
      };
    }
    
    return schema;
  }

  optimizeForSnippets(schema) {
    // Optimize for featured snippets
    
    // Ensure concise description for snippets
    if (schema.description && schema.description.length > 160) {
      const brief = schema.description.substring(0, 157) + '...';
      schema.disambiguatingDescription = brief;
    }
    
    // Add list structure if applicable
    if (schema['@type'] === 'HowTo') {
      schema.step = schema.step || [];
    }
    
    return schema;
  }
}
```

**Estimated:** 1.5 days

---

### Feature 4: Visual Search Optimizer (Rule-Based)

**File:** `index.js` (Update VisualSearchOptimizer class)

**Estimated:** 1.5 days

---

### Feature 5: 10 New Schema Templates

**File:** `index.js` (Add to Templates namespace)

**New Templates:**
1. ProductBundle
2. ProductVariant  
3. ServiceArea
4. MultiLocationBusiness
5. BlogSeries
6. Tutorial
7. FAQ Collection
8. ProfessionalService
9. Testimonial
10. Certification

**Estimated:** 1 day

---

### Feature 6: Enhanced Keyword Extraction

**File:** `index.js` (Update AI._extractKeywords)

**Improvements:**
- TF-IDF-inspired scoring
- Multi-word keyword detection
- Stop word filtering
- Noun phrase extraction

**Estimated:** 0.5 days

---

### Feature 7: Enhanced Entity Recognition

**File:** `index.js` (Update AI._extractEntities)

**Improvements:**
- Better pattern matching
- Context-aware extraction
- Price/currency detection
- Date/time recognition
- Email/phone extraction

**Estimated:** 0.5 days

---

### Feature 8: Basic Schema Relationships

**File:** `index.js` (New SchemaRelationships namespace)

**Features:**
- Detect parent-child relationships
- Find "mentions" connections
- Link authors to organizations
- Suggest related schemas

**Estimated:** 1 day

---

### Feature 9: Testing

**Files:** New test files

- `test/ai-optimizers-v11.test.js` - All 4 optimizers
- `test/new-templates-v11.test.js` - New templates
- `test/enhanced-analysis-v11.test.js` - Better extraction
- `test/schema-relationships.test.js` - Relationship detection

**Estimated:** 1.5 days

---

### Feature 10: Documentation

**Files:** Multiple

- Update README.md
- Create RELEASE_NOTES_v1.11.0.md
- Update CLI help text
- Add examples for new templates
- API documentation updates

**Estimated:** 1 day

---

## ðŸ“… 2-Week Sprint Schedule

### Week 1: Core Implementation

**Days 1-2:** Bard & Perplexity Optimizers
**Days 3-4:** Voice & Visual Optimizers  
**Day 5:** New Schema Templates

### Week 2: Polish & Launch

**Days 6-7:** Enhanced Analysis (Keywords & Entities)
**Day 8:** Schema Relationships
**Days 9-10:** Comprehensive Testing
**Days 11-12:** Documentation & Polish
**Days 13-14:** Final testing, release prep

---

## ðŸ“Š Success Criteria

- [ ] All 4 optimizers production-ready
- [ ] 10+ new templates added
- [ ] Keyword extraction quality improved 50%
- [ ] Entity recognition accuracy improved 40%
- [ ] All tests passing (95%+ coverage)
- [ ] Bundle size <9 kB gzipped
- [ ] Zero breaking changes
- [ ] Documentation complete

---

## ðŸŽ¯ Risk Mitigation

1. **Bundle Size Risk**: Monitor continuously, optimize if needed
2. **Testing Time**: Start tests early, parallel with development
3. **Documentation Lag**: Write docs alongside features
4. **Complexity Creep**: Stick to plan, defer extras to v1.12.0

---

## ðŸš€ Post-Release

After v1.11.0 release:
- Gather user feedback
- Monitor bundle size impact
- Plan v1.12.0 (Enterprise features, optional APIs)
- Fix any issues discovered


